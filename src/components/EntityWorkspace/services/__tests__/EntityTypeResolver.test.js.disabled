import { EntityTypeResolver } from '../EntityTypeResolver';

// Mock modelConfigs
jest.mock('@/modelConfigs', () => ({
  modelConfigs: {
    krav: {
      title: 'Krav',
      queryKey: ['krav'],
      queryFn: jest.fn(),
      workspace: { features: { grouping: true } }
    },
    prosjektKrav: {
      title: 'Prosjekt Krav',
      queryKey: ['prosjekt-krav'],
      queryFnAll: jest.fn()
    },
    combinedEntities: {
      title: 'Krav og Tiltak',
      queryKey: ['combined']
    }
  }
}));

describe('EntityTypeResolver', () => {
  describe('resolveModelConfig', () => {
    it('should resolve direct config lookup', () => {
      const result = EntityTypeResolver.resolveModelConfig('krav');
      expect(result.title).toBe('Krav');
    });

    it('should resolve kebab-case to camelCase', () => {
      const result = EntityTypeResolver.resolveModelConfig('prosjekt-krav');
      expect(result.title).toBe('Prosjekt Krav');
    });

    it('should handle special mappings', () => {
      const result = EntityTypeResolver.resolveModelConfig('combined');
      expect(result.title).toBe('Krav og Tiltak');
    });

    it('should create fallback config for unknown types', () => {
      console.warn = jest.fn(); // Mock console.warn
      
      const result = EntityTypeResolver.resolveModelConfig('unknownType');
      
      expect(result).toEqual(expect.objectContaining({
        title: 'UnknownType',
        modelPrintName: 'unknownType',
        queryKey: ['unknownType'],
        workspace: expect.objectContaining({
          enabled: true,
          features: expect.objectContaining({
            grouping: true,
            hierarchy: false,
            inlineEdit: true
          })
        })
      }));
      
      expect(console.warn).toHaveBeenCalledWith(
        'Creating fallback config for unknown entity type: unknownType'
      );
    });
  });

  describe('resolveApiConfig', () => {
    const mockModelConfig = {
      queryFn: jest.fn(),
      queryFnGroupedByEmne: jest.fn(),
      createFn: jest.fn(),
      updateFn: jest.fn(),
      deleteFn: jest.fn()
    };

    it('should return existing API functions from modelConfig', () => {
      const result = EntityTypeResolver.resolveApiConfig('krav', mockModelConfig);
      
      expect(result).toEqual({
        queryFn: mockModelConfig.queryFn,
        queryFnGroupedByEmne: mockModelConfig.queryFnGroupedByEmne,
        createFn: mockModelConfig.createFn,
        updateFn: mockModelConfig.updateFn,
        deleteFn: mockModelConfig.deleteFn
      });
    });

    it('should use queryFnAll as fallback for queryFn', () => {
      const configWithQueryFnAll = {
        queryFnAll: jest.fn(),
        createFn: jest.fn()
      };
      
      const result = EntityTypeResolver.resolveApiConfig('test', configWithQueryFnAll);
      expect(result.queryFn).toBe(configWithQueryFnAll.queryFnAll);
    });

    it('should handle missing API functions', () => {
      console.warn = jest.fn();
      
      const result = EntityTypeResolver.resolveApiConfig('test', {});
      
      expect(result).toEqual({
        queryFn: null,
        queryFnGroupedByEmne: null,
        createFn: null,
        updateFn: null,
        deleteFn: null
      });
      
      expect(console.warn).toHaveBeenCalledWith(
        'No API functions configured for entity type: test'
      );
    });
  });

  describe('getDisplayName', () => {
    it('should return title from modelConfig', () => {
      const mockConfig = { title: 'Test Title' };
      const result = EntityTypeResolver.getDisplayName('test', mockConfig);
      expect(result).toBe('Test Title');
    });

    it('should return plural form when requested', () => {
      const mockConfig = { title: 'Krav' };
      const result = EntityTypeResolver.getDisplayName('krav', mockConfig, true);
      expect(result).toBe('Kraver'); // Simple pluralization
    });

    it('should return default display names', () => {
      expect(EntityTypeResolver.getDisplayName('krav', {})).toBe('Krav');
      expect(EntityTypeResolver.getDisplayName('tiltak', {})).toBe('Tiltak');
      expect(EntityTypeResolver.getDisplayName('combined', {})).toBe('Krav og Tiltak');
    });

    it('should capitalize unknown entity types', () => {
      const result = EntityTypeResolver.getDisplayName('unknownType', {});
      expect(result).toBe('UnknownType');
    });
  });

  describe('supportsFeature', () => {
    it('should return feature from workspace config', () => {
      const mockConfig = {
        workspace: {
          features: {
            grouping: false,
            hierarchy: true
          }
        }
      };
      
      expect(EntityTypeResolver.supportsFeature('krav', 'grouping', mockConfig)).toBe(false);
      expect(EntityTypeResolver.supportsFeature('krav', 'hierarchy', mockConfig)).toBe(true);
    });

    it('should return entity type specific rules', () => {
      expect(EntityTypeResolver.supportsFeature('tiltak', 'hierarchy', {})).toBe(true);
      expect(EntityTypeResolver.supportsFeature('combined', 'inlineEdit', {})).toBe(false);
      expect(EntityTypeResolver.supportsFeature('krav', 'bulkActions', {})).toBe(true);
    });

    it('should return default values for unknown features', () => {
      expect(EntityTypeResolver.supportsFeature('krav', 'search', {})).toBe(true);
      expect(EntityTypeResolver.supportsFeature('krav', 'unknownFeature', {})).toBe(false);
    });
  });

  describe('detectEntityType', () => {
    it('should detect from entityType property', () => {
      const entity = { entityType: 'krav', id: 1 };
      expect(EntityTypeResolver.detectEntityType(entity)).toBe('krav');
    });

    it('should detect from UID properties', () => {
      expect(EntityTypeResolver.detectEntityType({ kravUID: 'K001' })).toBe('krav');
      expect(EntityTypeResolver.detectEntityType({ tiltakUID: 'T001' })).toBe('tiltak');
      expect(EntityTypeResolver.detectEntityType({ prosjektKravUID: 'PK001' })).toBe('prosjektKrav');
      expect(EntityTypeResolver.detectEntityType({ prosjektTiltakUID: 'PT001' })).toBe('prosjektTiltak');
    });

    it('should return unknown for entities with id and tittel but no specific identifiers', () => {
      const entity = { id: 1, tittel: 'Test Entity' };
      expect(EntityTypeResolver.detectEntityType(entity)).toBe('unknown');
    });

    it('should return null for invalid inputs', () => {
      expect(EntityTypeResolver.detectEntityType(null)).toBe(null);
      expect(EntityTypeResolver.detectEntityType(undefined)).toBe(null);
      expect(EntityTypeResolver.detectEntityType('string')).toBe(null);
      expect(EntityTypeResolver.detectEntityType({})).toBe(null);
    });
  });

  describe('validateEntityType', () => {
    it('should validate known entity type', () => {
      const result = EntityTypeResolver.validateEntityType('krav');
      
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should fail validation for missing entity type', () => {
      const result = EntityTypeResolver.validateEntityType();
      
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Entity type is required');
    });

    it('should fail validation for non-string entity type', () => {
      const result = EntityTypeResolver.validateEntityType(123);
      
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Entity type must be a string');
    });

    it('should create fallback config for unknown entity type but still validate', () => {
      console.warn = jest.fn();
      
      const result = EntityTypeResolver.validateEntityType('unknownType');
      
      expect(result.isValid).toBe(true); // Fallback config is created
      expect(result.errors).toHaveLength(0);
    });
  });

  describe('private helper methods', () => {
    describe('_toCamelCase', () => {
      it('should convert kebab-case to camelCase', () => {
        expect(EntityTypeResolver._toCamelCase('prosjekt-krav')).toBe('prosjektKrav');
        expect(EntityTypeResolver._toCamelCase('multi-word-example')).toBe('multiWordExample');
        expect(EntityTypeResolver._toCamelCase('singleword')).toBe('singleword');
      });
    });

    describe('_capitalize', () => {
      it('should capitalize first letter', () => {
        expect(EntityTypeResolver._capitalize('test')).toBe('Test');
        expect(EntityTypeResolver._capitalize('TEST')).toBe('TEST');
        expect(EntityTypeResolver._capitalize('')).toBe('');
      });
    });

    describe('_pluralize', () => {
      it('should add "er" to words not ending in "s"', () => {
        expect(EntityTypeResolver._pluralize('krav')).toBe('kraver');
        expect(EntityTypeResolver._pluralize('tiltak')).toBe('tiltaker');
      });

      it('should not modify words ending in "s"', () => {
        expect(EntityTypeResolver._pluralize('status')).toBe('status');
      });
    });

    describe('feature support methods', () => {
      it('should correctly identify hierarchical types', () => {
        expect(EntityTypeResolver._supportsHierarchy('tiltak')).toBe(true);
        expect(EntityTypeResolver._supportsHierarchy('prosjektTiltak')).toBe(true);
        expect(EntityTypeResolver._supportsHierarchy('krav')).toBe(true);
        expect(EntityTypeResolver._supportsHierarchy('combined')).toBe(false);
      });

      it('should correctly identify inline edit support', () => {
        expect(EntityTypeResolver._supportsInlineEdit('krav')).toBe(true);
        expect(EntityTypeResolver._supportsInlineEdit('combined')).toBe(false);
        expect(EntityTypeResolver._supportsInlineEdit('combinedEntities')).toBe(false);
      });

      it('should correctly identify bulk action support', () => {
        expect(EntityTypeResolver._supportsBulkActions('krav')).toBe(true);
        expect(EntityTypeResolver._supportsBulkActions('tiltak')).toBe(true);
        expect(EntityTypeResolver._supportsBulkActions('combined')).toBe(false);
      });
    });
  });
});