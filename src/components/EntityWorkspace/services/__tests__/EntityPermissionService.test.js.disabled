import { EntityPermissionService } from '../EntityPermissionService';

// Mock modelConfigs
jest.mock('@/modelConfigs', () => ({
  modelConfigs: {
    krav: {
      title: 'Krav',
      newButtonLabel: 'Nytt Krav',
      workspace: { features: { inlineEdit: true } }
    },
    tiltak: {
      title: 'Tiltak',
      newButtonLabelText: 'Nytt Tiltak',
      readOnly: false
    },
    readOnlyModel: {
      title: 'Read Only',
      readOnly: true
    }
  }
}));

describe('EntityPermissionService', () => {
  const mockModelConfig = {
    title: 'Test Entity',
    newButtonLabel: 'Nytt Test',
    readOnly: false
  };

  const mockReadOnlyConfig = {
    title: 'Read Only Entity',
    readOnly: true
  };

  const mockEntity = {
    id: 1,
    tittel: 'Test Entity',
    status: { navn: 'Aktiv' }
  };

  describe('resolveWorkspacePermissions', () => {
    it('should return default permissions for normal entity', () => {
      const result = EntityPermissionService.resolveWorkspacePermissions(
        'krav', 
        mockModelConfig
      );
      
      expect(result).toEqual(expect.objectContaining({
        canEdit: true,
        canDelete: true,
        canCreate: true,
        canBulkActions: false,
        editButtonText: 'Rediger',
        createButtonText: 'Nytt Test'
      }));
      
      expect(typeof result.deleteConfirmText).toBe('function');
    });

    it('should restrict permissions for read-only model', () => {
      const result = EntityPermissionService.resolveWorkspacePermissions(
        'readOnly',
        mockReadOnlyConfig
      );
      
      expect(result).toEqual(expect.objectContaining({
        canEdit: false,
        canDelete: false,
        canCreate: false,
        canBulkActions: false
      }));
    });

    it('should restrict permissions based on workspace config', () => {
      const workspaceConfig = {
        features: {
          inlineEdit: false,
          bulkActions: false
        }
      };
      
      const result = EntityPermissionService.resolveWorkspacePermissions(
        'krav',
        mockModelConfig,
        workspaceConfig
      );
      
      expect(result.canEdit).toBe(false);
      expect(result.canBulkActions).toBe(false);
    });

    it('should disable create for combined views', () => {
      const result = EntityPermissionService.resolveWorkspacePermissions(
        'combined',
        mockModelConfig
      );
      
      expect(result.canCreate).toBe(false);
    });
  });

  describe('resolveEntityPermissions', () => {
    it('should return workspace permissions for regular entity', () => {
      const result = EntityPermissionService.resolveEntityPermissions(
        mockEntity,
        'krav',
        mockModelConfig
      );
      
      expect(result.canEdit).toBe(true);
      expect(result.canDelete).toBe(true);
    });

    it('should resolve permissions for combined view entity', () => {
      const combinedEntity = {
        ...mockEntity,
        entityType: 'krav'
      };
      
      const result = EntityPermissionService.resolveEntityPermissions(
        combinedEntity,
        'combined',
        mockModelConfig
      );
      
      expect(result.canEdit).toBe(true);
      expect(result.editButtonText).toBe('Rediger Krav');
    });

    it('should apply business rules for locked entities', () => {
      const lockedEntity = {
        ...mockEntity,
        status: { navn: 'Låst' }
      };
      
      const result = EntityPermissionService.resolveEntityPermissions(
        lockedEntity,
        'krav',
        mockModelConfig
      );
      
      expect(result.canEdit).toBe(false);
      expect(result.canDelete).toBe(false);
    });
  });

  describe('canPerformAction', () => {
    it('should validate create action', () => {
      const result = EntityPermissionService.canPerformAction(
        'create',
        mockEntity,
        'krav',
        mockModelConfig
      );
      
      expect(result).toBe(true);
    });

    it('should validate edit action', () => {
      const result = EntityPermissionService.canPerformAction(
        'edit',
        mockEntity,
        'krav',
        mockModelConfig
      );
      
      expect(result).toBe(true);
    });

    it('should validate delete action', () => {
      const result = EntityPermissionService.canPerformAction(
        'delete',
        mockEntity,
        'krav',
        mockModelConfig
      );
      
      expect(result).toBe(true);
    });

    it('should return false for unknown action', () => {
      const result = EntityPermissionService.canPerformAction(
        'unknownAction',
        mockEntity,
        'krav',
        mockModelConfig
      );
      
      expect(result).toBe(false);
    });

    it('should respect read-only restrictions', () => {
      const createResult = EntityPermissionService.canPerformAction(
        'create',
        mockEntity,
        'readOnly',
        mockReadOnlyConfig
      );
      
      const editResult = EntityPermissionService.canPerformAction(
        'edit',
        mockEntity,
        'readOnly',
        mockReadOnlyConfig
      );
      
      expect(createResult).toBe(false);
      expect(editResult).toBe(false);
    });
  });

  describe('getActionButtonText', () => {
    it('should return create button text', () => {
      const result = EntityPermissionService.getActionButtonText(
        'create',
        mockEntity,
        'krav',
        mockModelConfig
      );
      
      expect(result).toBe('Nytt Test');
    });

    it('should return edit button text', () => {
      const result = EntityPermissionService.getActionButtonText(
        'edit',
        mockEntity,
        'krav',
        mockModelConfig
      );
      
      expect(result).toBe('Rediger');
    });

    it('should return delete confirmation text', () => {
      const result = EntityPermissionService.getActionButtonText(
        'delete',
        mockEntity,
        'krav',
        mockModelConfig
      );
      
      expect(result).toBe('Er du sikker på at du vil slette "Test Entity"?');
    });
  });

  describe('validateEntityOperation', () => {
    it('should validate create operation successfully', () => {
      const validEntity = {
        tittel: 'Valid Title',
        emneId: null,
        krav: []
      };
      
      const result = EntityPermissionService.validateEntityOperation(
        'create',
        validEntity
      );
      
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should validate update operation successfully', () => {
      const validEntity = {
        id: 1,
        tittel: 'Valid Title',
        emneId: null,
        krav: []
      };
      
      const result = EntityPermissionService.validateEntityOperation(
        'update',
        validEntity
      );
      
      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should fail validation for missing title', () => {
      const invalidEntity = {
        tittel: '',
        emneId: null,
        krav: []
      };
      
      const result = EntityPermissionService.validateEntityOperation(
        'create',
        invalidEntity
      );
      
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Tittel is required');
    });

    it('should fail validation when emne assigned with krav relationships', () => {
      const invalidEntity = {
        tittel: 'Valid Title',
        emneId: 1,
        krav: [{ id: 1, tittel: 'Related Krav' }]
      };
      
      const result = EntityPermissionService.validateEntityOperation(
        'update',
        invalidEntity
      );
      
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Cannot assign emne when entity has krav relationships');
    });
  });

  describe('private helper methods', () => {
    describe('_isCombinedView', () => {
      it('should identify combined view entity types', () => {
        expect(EntityPermissionService._isCombinedView('combined')).toBe(true);
        expect(EntityPermissionService._isCombinedView('combinedEntities')).toBe(true);
        expect(EntityPermissionService._isCombinedView('prosjekt-combined')).toBe(true);
        expect(EntityPermissionService._isCombinedView('krav')).toBe(false);
      });
    });

    describe('_mapEntityTypeToModelName', () => {
      it('should map entity types to model names', () => {
        expect(EntityPermissionService._mapEntityTypeToModelName('krav')).toBe('krav');
        expect(EntityPermissionService._mapEntityTypeToModelName('tiltak')).toBe('tiltak');
        expect(EntityPermissionService._mapEntityTypeToModelName('prosjektkrav')).toBe('prosjektKrav');
        expect(EntityPermissionService._mapEntityTypeToModelName('unknown')).toBeUndefined();
      });
    });

    describe('_hasKravRelationship', () => {
      it('should detect krav relationships', () => {
        const entityWithKrav = { krav: [{ id: 1 }] };
        const entityWithoutKrav = { krav: [] };
        const entityNoKravProperty = {};
        
        expect(EntityPermissionService._hasKravRelationship(entityWithKrav)).toBe(true);
        expect(EntityPermissionService._hasKravRelationship(entityWithoutKrav)).toBe(false);
        expect(EntityPermissionService._hasKravRelationship(entityNoKravProperty)).toBe(false);
      });
    });
  });
});