import { renderHook } from '@testing-library/react';
import { useEntityFiltering } from '../useEntityFiltering';

// Mock the EntityFilterService
jest.mock('../services/EntityFilterService', () => ({
  EntityFilterService: {
    extractAvailableFilters: jest.fn(),
    applyFilters: jest.fn(),
    calculateStats: jest.fn()
  }
}));

import { EntityFilterService } from '../services/EntityFilterService';

describe('useEntityFiltering', () => {
  const mockItems = [
    { id: 1, tittel: 'Test 1', status: { navn: 'Aktiv' } },
    { id: 2, tittel: 'Test 2', status: { navn: 'Inaktiv' } }
  ];

  const mockAvailableFilters = {
    statuses: ['Aktiv', 'Inaktiv'],
    vurderinger: ['Høy', 'Lav'],
    emner: ['Støy', 'Luft'],
    priorities: ['høy', 'lav']
  };

  const mockFilteredItems = [mockItems[0]]; // Only first item after filtering

  const mockStats = {
    total: 1,
    obligatorisk: 1,
    optional: 0
  };

  beforeEach(() => {
    EntityFilterService.extractAvailableFilters.mockReturnValue(mockAvailableFilters);
    EntityFilterService.applyFilters.mockReturnValue(mockFilteredItems);
    EntityFilterService.calculateStats.mockReturnValue(mockStats);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should extract available filters from items', () => {
    const { result } = renderHook(() =>
      useEntityFiltering({
        items: mockItems,
        entityType: 'krav'
      })
    );

    expect(EntityFilterService.extractAvailableFilters).toHaveBeenCalledWith(mockItems, 'krav');
    expect(result.current.availableStatuses).toEqual(['Aktiv', 'Inaktiv']);
    expect(result.current.availableVurderinger).toEqual(['Høy', 'Lav']);
    expect(result.current.availableEmner).toEqual(['Støy', 'Luft']);
    expect(result.current.availablePriorities).toEqual(['høy', 'lav']);
  });

  it('should apply filters to items', () => {
    const filters = { status: 'Aktiv' };
    const additionalFilters = { priority: 'høy' };

    const { result } = renderHook(() =>
      useEntityFiltering({
        items: mockItems,
        entityType: 'krav',
        filters,
        additionalFilters
      })
    );

    expect(EntityFilterService.applyFilters).toHaveBeenCalledWith(
      mockItems,
      { status: 'Aktiv', priority: 'høy' },
      'krav',
      false
    );
    expect(result.current.filteredItems).toEqual(mockFilteredItems);
  });

  it('should calculate filtered statistics', () => {
    const { result } = renderHook(() =>
      useEntityFiltering({
        items: mockItems,
        entityType: 'krav'
      })
    );

    expect(EntityFilterService.calculateStats).toHaveBeenCalledWith(
      mockFilteredItems,
      'krav',
      false
    );
    expect(result.current.filteredStats).toEqual(mockStats);
  });

  it('should detect active filters', () => {
    const { result: resultNoFilters } = renderHook(() =>
      useEntityFiltering({
        items: mockItems,
        filters: {},
        additionalFilters: {}
      })
    );

    expect(resultNoFilters.current.hasActiveFilters).toBe(false);
    expect(resultNoFilters.current.activeFilterCount).toBe(0);

    const { result: resultWithFilters } = renderHook(() =>
      useEntityFiltering({
        items: mockItems,
        filters: { status: 'Aktiv', filterBy: 'obligatorisk' },
        additionalFilters: { priority: 'høy' }
      })
    );

    expect(resultWithFilters.current.hasActiveFilters).toBe(true);
    expect(resultWithFilters.current.activeFilterCount).toBe(3);
  });

  it('should generate filter summary', () => {
    const { result } = renderHook(() =>
      useEntityFiltering({
        items: mockItems,
        filters: { status: 'Aktiv' },
        additionalFilters: { priority: 'høy', vurdering: 'Lav' }
      })
    );

    expect(result.current.filterSummary).toEqual([
      'Status: Aktiv',
      'Prioritet: høy',
      'Vurdering: Lav'
    ]);
  });

  it('should provide helper functions', () => {
    const { result } = renderHook(() =>
      useEntityFiltering({
        items: mockItems,
        filters: { status: 'Aktiv' },
        additionalFilters: { priority: 'høy' }
      })
    );

    expect(result.current.isFilterActive('status')).toBe(true);
    expect(result.current.isFilterActive('vurdering')).toBe(false);
    
    expect(result.current.getFilterDisplayValue('status')).toBe('Aktiv');
    expect(result.current.getFilterDisplayValue('vurdering')).toBe('all');
  });

  it('should handle grouped data', () => {
    const { result } = renderHook(() =>
      useEntityFiltering({
        items: mockItems,
        entityType: 'krav',
        groupByEmne: true,
        filters: { status: 'Aktiv' }
      })
    );

    expect(EntityFilterService.applyFilters).toHaveBeenCalledWith(
      mockItems,
      { status: 'Aktiv' },
      'krav',
      true
    );
    expect(EntityFilterService.calculateStats).toHaveBeenCalledWith(
      mockFilteredItems,
      'krav',
      true
    );
  });

  it('should handle empty items array', () => {
    const { result } = renderHook(() =>
      useEntityFiltering({
        items: [],
        entityType: 'krav'
      })
    );

    expect(EntityFilterService.extractAvailableFilters).toHaveBeenCalledWith([], 'krav');
    expect(result.current.filteredItems).toEqual([]);
  });

  it('should handle undefined items', () => {
    const { result } = renderHook(() =>
      useEntityFiltering({
        items: undefined,
        entityType: 'krav'
      })
    );

    expect(EntityFilterService.extractAvailableFilters).toHaveBeenCalledWith(undefined, 'krav');
    expect(result.current.filteredItems).toEqual(undefined);
  });

  it('should ignore filters with "all" or empty values', () => {
    const { result } = renderHook(() =>
      useEntityFiltering({
        items: mockItems,
        filters: { 
          status: 'all', 
          vurdering: '', 
          priority: 'høy' 
        }
      })
    );

    expect(result.current.hasActiveFilters).toBe(true); // Only priority is active
    expect(result.current.activeFilterCount).toBe(1);
    expect(result.current.filterSummary).toEqual(['Prioritet: høy']);
  });
});